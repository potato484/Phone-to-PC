import fs from 'node:fs/promises';
import path from 'node:path';
import process from 'node:process';
import { fileURLToPath } from 'node:url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const repoRoot = path.resolve(__dirname, '..');
const defaultSourcePath = path.join(repoRoot, 'design-tokens', 'c2p.tokens.json');
const defaultOutPath = path.join(repoRoot, 'public', 'tokens.css');

function parseArgs(argv) {
  const args = {
    source: defaultSourcePath,
    out: defaultOutPath,
    check: false,
    stdout: false
  };

  for (let i = 0; i < argv.length; i += 1) {
    const token = argv[i];
    if (token === '--check') {
      args.check = true;
      continue;
    }
    if (token === '--stdout') {
      args.stdout = true;
      continue;
    }
    if (token === '--source' || token === '--src') {
      const next = argv[i + 1];
      if (!next) {
        throw new Error(`${token} requires a path`);
      }
      args.source = path.resolve(repoRoot, next);
      i += 1;
      continue;
    }
    if (token === '--out') {
      const next = argv[i + 1];
      if (!next) {
        throw new Error(`${token} requires a path`);
      }
      args.out = path.resolve(repoRoot, next);
      i += 1;
      continue;
    }
    throw new Error(`unknown argument: ${token}`);
  }

  return args;
}

function isPlainObject(value) {
  return !!value && typeof value === 'object' && !Array.isArray(value);
}

function validateVarsMap(label, vars) {
  if (!isPlainObject(vars)) {
    throw new Error(`${label} must be an object`);
  }
  const entries = Object.entries(vars);
  for (const [key, value] of entries) {
    if (typeof key !== 'string' || !key.trim()) {
      throw new Error(`${label} contains empty key`);
    }
    if (typeof value !== 'string' || !value.trim()) {
      throw new Error(`${label}.${key} must be a non-empty string`);
    }
    if (key.includes('--') || key.includes(':') || key.includes(';') || key.includes('{') || key.includes('}')) {
      throw new Error(`${label}.${key} contains invalid characters`);
    }
  }
  return Object.fromEntries(entries);
}

function validateAliasesMap(aliases) {
  if (!isPlainObject(aliases)) {
    throw new Error(`aliases must be an object`);
  }
  const entries = Object.entries(aliases);
  for (const [key, value] of entries) {
    if (typeof key !== 'string' || !key.trim()) {
      throw new Error(`aliases contains empty key`);
    }
    if (typeof value !== 'string' || !value.trim()) {
      throw new Error(`aliases.${key} must be a non-empty string`);
    }
    if (key.includes('--') || key.includes(':') || key.includes(';') || key.includes('{') || key.includes('}')) {
      throw new Error(`aliases.${key} contains invalid characters`);
    }
    if (
      value.includes('--') ||
      value.includes(':') ||
      value.includes(';') ||
      value.includes('{') ||
      value.includes('}') ||
      value.includes(' ')
    ) {
      throw new Error(`aliases.${key} points to an invalid variable name`);
    }
  }
  return Object.fromEntries(entries);
}

function stableVarLines(vars) {
  return Object.keys(vars)
    .sort((a, b) => a.localeCompare(b))
    .map((key) => `  --${key}: ${vars[key]};`);
}

function stableAliasLines(aliases) {
  return Object.keys(aliases)
    .sort((a, b) => a.localeCompare(b))
    .map((key) => `  --${key}: var(--${aliases[key]});`);
}

function buildCss({ sourcePath, sharedVars, darkTheme, lightTheme, aliases }) {
  const sharedLines = stableVarLines(sharedVars);
  const darkLines = stableVarLines(darkTheme.vars);
  const lightLines = stableVarLines(lightTheme.vars);
  const aliasLines = stableAliasLines(aliases);

  const lines = [
    '/*',
    ' * This file is generated by scripts/build-tokens.mjs.',
    ` * Source: ${path.relative(repoRoot, sourcePath)}`,
    ' */',
    '',
    ':root {',
    `  color-scheme: ${darkTheme.colorScheme};`,
    ...sharedLines,
    '',
    ...darkLines,
    '',
    ...aliasLines,
    '}',
    '',
    '@media (prefers-color-scheme: light) {',
    '  :root:not([data-theme="dark"]) {',
    `    color-scheme: ${lightTheme.colorScheme};`,
    ...lightLines.map((line) => `  ${line}`),
    '  }',
    '}',
    '',
    ':root[data-theme="light"] {',
    `  color-scheme: ${lightTheme.colorScheme};`,
    ...lightLines,
    '}',
    ''
  ];

  return lines.join('\n');
}

async function loadTokens(sourcePath) {
  const raw = await fs.readFile(sourcePath, 'utf8');
  const parsed = JSON.parse(raw);
  if (!isPlainObject(parsed)) {
    throw new Error('tokens JSON must be an object');
  }

  const shared = isPlainObject(parsed.shared) ? parsed.shared : null;
  const themes = isPlainObject(parsed.themes) ? parsed.themes : null;
  if (!shared || !themes) {
    throw new Error('tokens JSON must contain shared and themes objects');
  }

  const sharedVars = validateVarsMap('shared.vars', shared.vars);

  const darkTheme = isPlainObject(themes.dark) ? themes.dark : null;
  const lightTheme = isPlainObject(themes.light) ? themes.light : null;
  if (!darkTheme || !lightTheme) {
    throw new Error('tokens JSON must contain themes.dark and themes.light objects');
  }

  const dark = {
    colorScheme: darkTheme.colorScheme === 'dark' ? 'dark' : 'dark',
    vars: validateVarsMap('themes.dark.vars', darkTheme.vars)
  };
  const light = {
    colorScheme: lightTheme.colorScheme === 'light' ? 'light' : 'light',
    vars: validateVarsMap('themes.light.vars', lightTheme.vars)
  };

  const aliases = validateAliasesMap(parsed.aliases);

  return {
    sharedVars,
    dark,
    light,
    aliases
  };
}

async function main() {
  const args = parseArgs(process.argv.slice(2));
  const tokens = await loadTokens(args.source);
  const css = buildCss({
    sourcePath: args.source,
    sharedVars: tokens.sharedVars,
    darkTheme: tokens.dark,
    lightTheme: tokens.light,
    aliases: tokens.aliases
  });

  if (args.stdout) {
    await new Promise((resolve) => {
      process.stdout.write(css, resolve);
    });
    return;
  }

  if (args.check) {
    let existing = '';
    try {
      existing = await fs.readFile(args.out, 'utf8');
    } catch {
      console.error(`[tokens] missing output: ${path.relative(repoRoot, args.out)}`);
      console.error('[tokens] run: pnpm tokens:build');
      process.exitCode = 1;
      return;
    }
    if (existing !== css) {
      console.error(`[tokens] output out of date: ${path.relative(repoRoot, args.out)}`);
      console.error('[tokens] run: pnpm tokens:build');
      process.exitCode = 1;
    }
    return;
  }

  await fs.mkdir(path.dirname(args.out), { recursive: true });
  await fs.writeFile(args.out, css, 'utf8');
  console.log(`[tokens] wrote ${path.relative(repoRoot, args.out)}`);
}

main().catch((error) => {
  console.error(`[tokens] ${error instanceof Error ? error.message : String(error)}`);
  process.exitCode = 1;
});
